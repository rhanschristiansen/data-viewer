# External Libraries
import wx  # the GUI library
import cv2  # openCV
import matplotlib
import os
import pandas as pd
import math

# Custom Libraries
from src.gui_form.data_viewer import MyFrame_Data_Viewer
from src.gui_form.frame import Frame
from src.gui_form.kitti_viewer import MyFrame_Kitti_Viewer
import src.util.calibration_kitti as cal_kitti
import src.util.calibration as cal_santaclara
from util.util import set_is_old, update_run_date, initialize_gui_controls, update_weights, load_dataset
from util.util import enable_disable_features, update_cal, save_image_to_png, log_to_file, update_run_number
from util.drawing_util import update_displayed_object_lists, draw_bboxes, draw_detzone, draw_3d_bboxes
from util.drawing_util import draw_kitti_points, draw_lidar_values
from association.association_test import AssociationTest

matplotlib.use('WXAgg')
# TODO - add ability to run the YOLO detector live


class MyFrame(Frame):
    ''' The main GUI window of the viewer application

    This class is built on the Frame class that is generated by an external graphical development tools called
    wxFormBuilder (see https://github.com/wxFormBuilder/wxFormBuilder)

    The builder file is called Interactive_Viewer.fbp located in the src directory of this project

    By pressing the generate option under the File menu in wxFormBuilder the program automatically generates the
    Frame Class that myFrame inherits is behavior from. The Frame class is located in the file frame.py in the
    gui_form directory. wxFormBuilder also contains several other forms in other classes that are also contained
    in the frame.py file. The other classes are not instantiated in this file viewer.py but in other files
    including: kitti_contour.py, kitti_histogram.py, kitti_viewer.py, and data_viewer.py

    -----------Theory of Operation - a review of the "event driven" programming paradigm ------------------

    viewer.py is an event driven application that is initiated by a call to 4 lines of code at the very end of this file
    outside of the class definition. These lines are:

    app = wx.App()
    frame = MyFrame()
    frame.Show()
    app.MainLoop()

    the first line instantiates the wx Application which is built on the wx module imported above
    the second line instantiates the MyFrame class derived from the Frame class in the file frame.py
          (the __init__ method in this class is executed when this line is called.
    the third line calls the Show method of the MyFrame class displaying the GUI
    the fourth line calls the MainLoop method in the App class which catches mouse and keyboard activity as the user
          interacts with the GUI window.

    Much of the behavior of the Applicaiton window is handled behind the scenes in the wx module's code. Events such as
    resizing a window or closing a window are all handled in the standard wx module code and these behaviors are not
    customized unless desired by the designer. However, inside the GUI's window area, customizable controls and
    containers are specified by the designer to provide the end user with the ability to control the application and
    to accomplish the tasks and behaviors that the designer intends.

    There are 2 ways in which the designer customizes the GUI  - the first is by specifying recognizable names
    for each of the controls such as dropdown boxes,textControls or checkboxes that the user interacts with.

    The second way is by specifying methods that are associated with specific events that happen when the user
    presses a button or checks a box. The methods that are associated with these events are called Event Handlers.

    For instance, each time the user clicks on the "Go To Frame #" button on the screen, the designer has specified
    an event handler called "process_goto_frame_number" that is tied to the OnClick event for that button in the
    Frame class in the file frame.py. This is created automatically by the wxFormBuilder application.

    Event handlers are specified for each and every control and behavior that the designer desires for the GUI.
    Stubs of these event handlers are automatically generated by wxFormBuilder in the Frame class in the file frame.py.

    Because the Frame class in the file frame.py is generated automatically by the wxFormBuilder application, it is
    desireable that that frame.py file not be modified by the programmer. But each of the event handlers needs to be
    customized to tie the desired behavior of the program to the controls on the GUI. To accomplish this, the
    programmer overrides the event handler methods that are defined in the Frame class by redefining an event handler
    method of the same name in the MyFrame class that is inherited from Frame. In this way, the programmer does not
    need to change the Frame class directly but simply overrides the behavior in the MyFrame class.

    As a design choice, all of the event handler methods defined in this program begin with the word "process"
    to make them easy to spot. They are located at the bottom of the MyFrame class beginning with the
    method: process_get_data. You can also recognise them in the Pycharm IDE because they
    have a blue dot on the line number number bar.

    In addition to the custom event handlers that are specified, there are 2 additional events are called
    regularly throughout the life of the GUI:

    The first of these is an event called wx.EVT_PAINT. The PAINT event for the video display panel is bound to the
    custom method onPaint with the following line of code.

        self.m_panel_video_display.Bind(wx.EVT_PAINT, self.onPaint)

    so that every time the application determines that the video display panel needs to be "repainted" this event fires
    and the onPaint method is executed.

    The onPaint method is the main driver of activity in the program and every time it fires it reads the status of all
    of the important variables and refreshes the display based on the new information if necessary.

    The onPaint method calls several processes which update data as needed. The core of these processes are:
        load_dataset - which loads new data if necessary
        update_image - which updates the image and the frames of detection and lidar data

    To improve performance, both of these methods use a dictionary variable called "is_old" to keep track of whether
    the program needs to update certain type of data. This allows the programmer to decide whether to update
    a specific type of data rather than just updating in every time the onPaint method is fired which could be
    four times in a single update. One good example is the need to load a new dataset. This is only done when the
    application initializes or when the user selects a different run number. When that happens the following is set

        is_old['dataset'] = True

    This call, allows the program on the next call to onPaint to load the dataset which can take a second or more.

    Another example is the use_filtering checkbox. When that check box is set, the following is set

        is_old['filtering'] = True

    This call allows the program on the next call to onPaint to use Pandas to filter the dataset for the filtering
    required all at once rather than piecemeal each time a frame is executed. This greatly improves the
    responsiveness of the program and reduces the frame to frame latency for onPaint calls.

    The second of these special events mentioned above is an event that is generated by a wx.Timer object that is
    instantiated and bound to the onTimer method by the following two lines of code.

        self.timer = wx.Timer(self, wx.TIMER_CONTINUOUS)
        self.Bind(wx.EVT_TIMER, self.OnTimer)

    After the timer is set, the amount of time in milliseconds between timer events is specified below which is
    selectable by the Play Speed dropdown box. The third line below specifies the 20 millisecond timer period

        self.play_speed_idx = 0
        self.play_speeds = [20, 500, 2000]
        self.timer.Start(self.play_speeds[self.play_speed_idx])

    The timer is constantly firing timer events which are handled by the OnTimer event handler. Normally the timer
    events don't do anything because the variable is_playing = False. However, when the play button
    is pressed, this causes the is_playing to change to True which causes the frame to increment by 1 frame every time
    the timer event fires. This is how the playing operation works.

    -------------  IMPORTANT DEPENDENCIES ------------------

    gui_form/frame.py - contains the auto-generated code for the main window

    gui_form/data_viewer.py - contains the GUI form for the child window that pops up when the DATA VIEWER button is
        pressed.

    gui_form/kitti_viewer.py - contains the GUI form for the child window that pops up when the KITTI VIEWER button is
        pressed.

    gui_form/kitti_contour.py - contains a plot built in matplotlib that sits inside a panel in the kitti_viewer when a
        contour plot is displayed

    gui_form/kitti_histogram.py - contains a plot built in matplotlib that sits inside a panel in the kitti_viewer when
        a histogram plot is displayed.

    association/association_test.py - contains the AssociationTest class that drives all of the behavior of
        getting and organizing dataframes from the files and in performing the association process on the files.

    association/association.py - contains the Association class that performs the association task

    association/costs.py - contains the code that implements the individual cost funtions L2_norm, y2_est and IOU

    association/munkres.py - a externally sourced module locally installed that implements the hungarian algorithm

    detection/car_detector_tf_v2.py - the implementation of the YOLOv3 detector for cars

    detection/detection.py - the implentation of the Detection class

    images/* - all of the image files for the buttons on the player

    lidar/lidar_detection.py - the implementation of the LIDAR_Detection class

    lidar/lidar_data_filter.py - a utility function to get clean up stale lidar values in the data from the
        M16 polling method. There are several possible reasons for the stale values but it is uncertain exactly
        why stale values were still occuring. This utility was a temporary patch.

    segmentation/deeplab_v3.py - implementation of a segmentation approach using tensorflow - not used in viewer

    source/parseTrackletXML.py - a utility program used to parse the XML files for use by the Viewer

    source/utilities.py - a utility used by parseTrackletXML.py

    util/util.py - contains general utility methods for viewer.py

    util/drawing_util - contains drawing utility methods for viewer.py

    util/calibration.py - the calibration for the SantaClara camera/lidar pair

    util/calibration_kitti.py - the calibration for the Kitti camera/lidar setup

    util/eda_util.py - utilities used to explore the kitti dataset in jupyter notebook

    util/kitti_tools.py - utilities used by eda_util.py

    util/preprocess_kitti.py - a utility programe to pre processs detection data for the kitti dataset using YOLOv3
        needed for performance reasons

    util/preprocess_santaclara - a utility program to pre process detection data for the santa clarla dataset using
        YOLOv3 - needed for performance reasons

    util/transform.py - the implementation of the Transform class that contains numerous methods to transform
        LIDAR readings to the image plane and vis versa. Heavily relies on the calibration.py and the
        calibration_kitti.py files for accurate transformations of coordinates.'''

    def __init__(self):

        Frame.__init__(self, None)
        '''init has all of the major parameters for setup of the viewer main window
        
        initializes all of the class variables for the application and sets all of the controls in their
        initial state prior to launching the GUI form.
        '''

        # TODO - move the initialization parameters to a YAML file and add the ability to save current configuration

        # set initial values for all of the class variables

        # run_data is the folder name of the dataset, run_number is the index number for the run that day
        # run_tupes - whether the run is of the type santaclara or kitti so the program can adapt to different formats
        self.run_date_idx = 1
        self.run_number_idx = 0

        # TODO - add functionality to automatically scan the files and build the dataset (low priority)
        self.data_dir = '../../data/'
        self.run_dates = ['2011_09_26', '2018-09-18', '2018-09-20', '2018-12-17']
        self.run_numbers = {
            #'2011_09_26':['0001','0002','0005','0009','0015'],
            '2011_09_26':['0009','0015'],
            '2018-09-18': ['0002', '0003'],
            '2018-09-20': ['0002'],
            '2018-12-17': ['0002', '0003']
        }
        self.run_types = {
            '2011_09_26':'kitti',
            '2018-09-18':'santaclara',
            '2018-09-20':'santaclara',
            '2018-12-17':'santaclara'
        }
        self.run_date = self.run_dates[self.run_date_idx]
        self.run_number = self.run_numbers[self.run_dates[self.run_date_idx]][self.run_number_idx]
        self.run_type = self.run_types[self.run_dates[self.run_date_idx]]

        # toggled by the play button in the play control area
        self.is_playing = False

        # timer fires every 20, 500 or 2000 milliseconnds for fast, medium or slow playing
        self.timer = wx.Timer(self, wx.TIMER_CONTINUOUS)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.play_speed_idx = 0
        self.play_speeds = [20, 500, 2000]
        self.timer.Start(self.play_speeds[self.play_speed_idx])

        # n_segs controls the number of lidar segments displayed and used for calculation of associations
        self.n_segs_idx = 0
        self.n_segs_choices = [16,8,4,2,1]
        self.n_segs = self.n_segs_choices[self.n_segs_idx]
        self.seg_step = 16 // self.n_segs

        # turns on and off the mouse click pixel coordinates on the screen
        self.show_coord = True
        self.mouse_x = 0
        self.mouse_y = 0

        # variable holds the last right click distance projected to the ground
        self.click_dist = 0

        # variables for the controls on the screen and their initial values
        self.run_start_frame = 0
        self.run_stop_frame = 0
        self.use_detector = True
        self.min_det_confidence = 0.85
        self.enable_min_det_confidence = True
        self.use_filtered_data = True
        self.show_index_numbers = False
        self.show_kitti_points = False
        self.show_all_kitti_points = False
        self.show_detection_zones = True
        self.show_video_detections = True
        self.show_lidar_detections = False
        self.show_ground_truth = False
        self.show_associations = True
        self.show_3d_ground_truth = False
        self.show_lidar_values = True
        self.detection_zone_color = (255, 0, 0, 255)
        self.video_detections_color = (0, 0, 255, 255)
        self.lidar_detections_color = (255, 0, 0, 255)
        self.ground_truth_color = (0,255, 0, 255)
        self.associations_color = (255, 255, 0, 255)
        self.threeD_ground_truth_color = (255, 127, 0, 255)
        self.lidar_value_color = (255, 0, 0, 255)
        self.running = False
        self.goto_frame_number = 2572
        self.lag_frames_idx = 2
        self.lag_frames_choices = [0,1,2,3,4]
        self.lag_frames = self.lag_frames_choices[self.lag_frames_idx]
        self.enable_logging = False
        self.logging_filepath = '../../data/2018-09-18/viewer_logs/0001/'
        self.enable_save_png = False
        self.record_gt_filepath = '../../data/2018-09-18/viewer_logs/gt_records/'
        self.enable_record_gt = False
        self.gt_record_columns = ['det_frame', 'lidar_frame', 'association_index', 'is_valid',
                                  'is_manual', 'video_detection_index', 'lidar_detection_index',
                                  'detection_class', 'detection_confidence',
                                  'lidar_segment', 'lidar_distance', 'x1', 'y1', 'x2', 'y2']

#        self.gt_df_columns = ['frame_number', 'tracklet_index', 'label', 'x1', 'y1', 'x2', 'y2']
        self.remove_association_idx_frame = [] # the current frame's association index selections for removal

        # variables to prevent logging of the same frame multiple times - value = -1 means logger needs to write header
        self.last_frame_logged = -1
        self.last_frame_png_saved = -1
        self.right_click_messages = ['Right click on blue object circle to select for manual ground truth assignment.',
                                     'Right click on red lidar reading to assign distance to object or press m for manual distance assignment.',
                                     'Object manually added to ground truth records.']

        self.right_click_idx = 0
        self.right_click_lidar_locations = []
        self.right_click_association_idx = -1
        self.right_click_selected_object = -1
        self.manual_associations_gt = []
        self.manual_distance = -1
        self.manual_associations_idx_frame = [] # the current frame's manual distance object indexes for saving

        # these values are updated by the evaluate_run_association_accuracy method in association_test
        self.run_accuracy_details_columns = ['frame_num', 'gt_index', 'det_index', 'result']
        self.run_accuracy_details = pd.DataFrame([], columns=self.run_accuracy_details_columns)
        self.frame_total_possible = 0
        self.frame_true_positives = 0
        self.frame_false_positives = 0
        self.frame_false_negatives = 0
        self.run_true_positives = 0
        self.run_false_positives = 0
        self.run_false_negatives = 0
        self.run_total = 0
        self.run_accuracy = 0
        self.run_precision = 0
        self.run_recall = 0

        # min and max distances for lidar values and ground_truth objects (kitti)
        self.min_distance = 10
        self.max_distance = 200

        # create lists of current video objects
        self.df_list = []
        self.colors_list = []
        self.types_list = []

        # data frame objects to hold different data generated by AssociationTest class
        self.at = None
        self.gt_frame = None
        self.det_frame = None
        self.lidar_frame = None
        self.tracklet_df = None
        self.clustered_df_frame = None # all of the visible kitti points for the current frame
        self.clustered_segs_only = None  # just the kitti points in the lidar regions
        self.association_frame = None
        self.assignments_frame = None
        self.total_cost_frame = None
        self.l2_norm_cost_frame = None
        self.y2_est_cost_frame = None
        self.iou_cost_frame = None
        self.gt_record_df = None

        # initial weights and max_cost for the association processes
        self.l2_norm_weight = 0.34
        self.y2_est_weight = 0.33
        self.iou_weight = 0.33
        self.seg_intersect_weight = 0
        self.max_cost = 0.5
        self.enable_max_cost = True
        self.use_intersecting_only = True

        self.weights = [self.l2_norm_weight, self.y2_est_weight, self.iou_weight, self.seg_intersect_weight]
        # self.gt_object_classes = ['Car', 'Truck', 'Van']
        self.gt_object_classes = ['Car']
        # self.det_object_classes = ['car', 'truck', 'bus']
        self.det_object_classes = ['car']

        # get the information from the run_date and set up the run_number in the dropdown lists and start / stop
        update_run_date(self)
        self.m_staticText_start_stop.SetLabel('  {0:0.0f} / {1:0.0f}'.format(self.run_start_frame, self.run_stop_frame))

        # set up all of the GUI controls with the appropriate initial values
        initialize_gui_controls(self)

        # set the start frame and the current_frame labels
        self.current_frame = self.run_start_frame
        self.m_staticText_current_frame.SetLabelText('Current Frame: {}'.format(int(self.current_frame)))

        # keep track of the current frame when recording associations to ground truth
        self.update_association_frame_number = self.current_frame

        # set all of the is_old dictionary values to True so that everything gets updated during the first onPaint
        self.isOld = {
            'gt_frame'          : True,
            'det_frame'         : True,
            'lidar_frame'       : True,
            'association'       : True,
            'accuracy'          : False,
            'accuracy_settings' : True,
            'filtered'          : True,
            'image'             : True,
            'dataset'           : True,
            'clusters'          : True,
            'ground_truth'      : True
        }

        # create class level image variables
        self.image = None
        self.display_image = None
        self.bmp = None
        self.image_rows = None
        self.image_cols = None

        # load the dataset for the first time
        update_weights(self)
        load_dataset(self)
        enable_disable_features(self, self.run_types[self.run_date])
        self.m_staticText_start_stop.SetLabel('  {0:0.0f} / {1:0.0f}'.format(self.run_start_frame, self.run_stop_frame))
        self.m_panel_video_display.SetSize((self.image_cols, self.image_rows))
        self.m_button_get_data.Disable()

        # initialize the calibration and the boundaries of the lidar region
        self.cal = update_cal(self)
        self.lidar_left = self.cal.SEG_TO_PIXEL_LEFT[0]
        self.lidar_right = self.cal.SEG_TO_PIXEL_RIGHT[15]
        self.lidar_top = self.cal.SEG_TO_PIXEL_TOP
        self.lidar_bottom = self.cal.SEG_TO_PIXEL_BOTTOM

        # position the main window and bind the opPaint method to the main window
        self.SetPosition((100,100))
        self.m_panel_video_display.Bind(wx.EVT_PAINT, self.onPaint)

        # bind a key event to the frame
        self.m_panel_video_display.Bind(wx.EVT_KEY_DOWN,self.on_key_press)
        return

    def on_key_press(self, event):
        keycode = event.GetKeyCode()
        is_valid_key = False
        if keycode == wx.WXK_SPACE:
            self.current_frame += 1
            is_valid_key = True
        elif keycode == 66:
            self.current_frame -= 1
            is_valid_key = True
        elif keycode == wx.WXK_RETURN:
            if self.enable_record_gt:
                self.record_gt()
            self.current_frame += 1
            is_valid_key = True
        elif keycode == 77:
            if self.enable_record_gt:
                self.add_manual_distance()
                is_valid_key = True
        if is_valid_key:
            self.Refresh()
            set_is_old(self.isOld, 'list_true',
                       list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])

        event.Skip()
        return

    def OnTimer(self, event):
        '''Fires periodically to advance the video by one frame if is_playing is True.'''
        if self.is_playing:
            self.current_frame += 1
            # turn of the play when it reaches the end
            if self.current_frame == self.run_stop_frame:
                self.is_playing = False
            set_is_old(self.isOld, 'list_true',
                       list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
            self.Refresh()
            self.TopLevelParent.Refresh()
        return

    def update_image(self):
        '''The main method to update the image

        This is called by the opPaint method and does the major work of updating the image with the new data for the
        frame based on the current settings and based on what has become old in the "is_old" dictionary
        This is also the place that the get_frame method from the AssociationTest class is called.
        The final tasks in this method updates the class variable called so that it can be updated in opPaint
        '''
        # retrieve any changes to the weights from the GUI form
        update_weights(self)

        # retrieve any changes to the types of objects that the user wants to filter from the GUI form
        if ', '.join(self.det_object_classes) != self.m_textCtrl_classes.GetValue():
            self.det_object_classes = self.m_textCtrl_classes.GetValue().replace(" ", "").split(',')
            self.isOld['dataset'] = True

        # fetch the latest frame from AssociationTest
        self.image, self.gt_frame, self.det_frame, self.lidar_frame, self.association_frame = self.at.get_frame(2, self.current_frame, self.use_filtered_data, self.use_detector, self.weights, self.isOld, self.run_types[self.run_date])

        # update the list of associations to be removed from the ground truth if it is a new frame
        if self.enable_record_gt and self.update_association_frame_number != self.current_frame:
            self.remove_association_idx_frame = list(self.gt_record_df.loc[(self.gt_record_df['det_frame'] == self.current_frame) & (self.gt_record_df['is_valid'] == False)].association_index)
            self.valid_association_idx_frame = list(self.gt_record_df.loc[(self.gt_record_df['det_frame'] == self.current_frame) & (self.gt_record_df['is_valid'] == True)].association_index)
            manual_df = self.gt_record_df.loc[(self.gt_record_df['det_frame'] == self.current_frame) & (self.gt_record_df['is_manual'] == True)].copy()
            self.manual_associations_gt = []
            for i in range(len(manual_df)):
                manual_values = [manual_df.iloc[i,:].video_detection_index,  # det_index
                                 manual_df.iloc[i,:].lidar_detection_index,  # lidar_index
                                 manual_df.iloc[i,:].is_manual,  # is_manual_distance_entry
                                 manual_df.iloc[i,:].lidar_distance,  # distance
                                 True] # recorded
                self.manual_associations_gt.append(manual_values)
                self.remove_association_idx_frame.append(manual_df.iloc[i,:].association_index)
            self.update_association_frame_number = self.current_frame

        # if it is a kitti dataset, fetch the clustering data from kitti
        if self.run_types[self.run_date] == 'kitti':
            self.clustered_df_frame, self.clustered_segs_only = self.at.get_kitti_frame(self.current_frame)
        elif self.run_types[self.run_date] == 'santaclara':
            self.clustered_df_frame = None
            self.clustered_segs_only = None
        else:
            print('wrong run_type given: {}'.format(self.run_types[self.run_date]))

        # start the process of updating the display image by making a deep copy and based on the users preferences
        # for what to display, add information to the display_image
        self.display_image = self.image.copy()
        update_displayed_object_lists(self)

        self.display_image = draw_bboxes(self, self.display_image, self.df_list, self.colors_list, self.types_list)

        if self.show_detection_zones:
            self.display_image = draw_detzone(self, self.display_image, self.detection_zone_color[0:3])

        if self.show_3d_ground_truth:
            self.display_image = draw_3d_bboxes(self, self.display_image, [self.gt_frame], [self.threeD_ground_truth_color[0:3]], ['3d_ground_truth'])

        if self.show_kitti_points:
            self.display_image = draw_kitti_points(self, self.display_image)

        if self.show_lidar_values:
            self.display_image = draw_lidar_values(self, self.display_image, self.lidar_value_color)

        if self.show_coord:
            cv2.putText(self.display_image,'x: {0:0.0f}, y: {1:0.0f}'.format(self.mouse_x,self.mouse_y),(25,25),1,1.5,(255,0,0),2)
            cv2.putText(self.display_image,'click_dist: {0:0.2f}'.format(self.click_dist),(25,50),1,1.5,(255,0,0),2)
        else:
            self.mouse_x = 0
            self.mouse_y = 0
        if self.enable_record_gt:
            cv2.putText(self.display_image, self.right_click_messages[self.right_click_idx],(25,700),1,1,(255,0,0),2)
        return

    def onPaint(self, evt):
        '''This is the main onPaint method that is called frequently by the Application

        It accomplishes a large part of what it does by calling the sub functions as needed based on the settings
        in the "is_old" dictionary
        '''

        # make sure we stay in the range of frames that are available
        if self.current_frame < self.run_start_frame:
            self.current_frame = self.run_start_frame
        if self.current_frame > self.run_stop_frame:
            self.current_frame = self.run_stop_frame

        # update the dataset if old.
        if self.isOld['dataset']:
            update_weights(self)
            load_dataset(self)
            enable_disable_features(self, self.run_types[self.run_date])
            self.m_staticText_start_stop.SetLabel('  {0:0.0f} / {1:0.0f}'.format(self.run_start_frame, self.run_stop_frame))
            self.m_panel_video_display.SetSize((self.image_cols, self.image_rows))
            self.m_button_get_data.Disable()

        # update the image with calls to get_frame
        self.update_image()

        # if settings have changed enable the Update Run button to allow user to
        # update the accuracy numbers the the new settings
        if self.isOld['accuracy_settings']:
            self.m_button_update_run_results.Enable()
        else:
            self.m_button_update_run_results.Disable()

        # if the user has pressed the Update Run button, isOld['accuracy'] will be True
        if self.isOld['accuracy']:
            # make a new instance of the AssociationTest class so that we don't
            # interfere with existing variables settings
            self.m_staticText_run_total.SetLabel('...')
            self.m_staticText_run_true_positives.SetLabel('...')
            self.m_staticText_run_false_positives.SetLabel('...')
            self.m_staticText_run_false_negatives.SetLabel('...')
            self.m_staticText_run_accuracy.SetLabel('Accy: ...')
            self.m_staticText_run_precision.SetLabel('Prec: ...')
            self.m_staticText_run_recall.SetLabel('Rcall: ...')

            at2 = AssociationTest(self)
            at2.load_dataset(self.run_date, self.run_number)
            self.run_total, self.run_true_positives, self.run_false_positives, self.run_false_negatives, run_stats, run_object_details = at2.evaluate_run_association_accuracy(2, self.use_filtered_data, self.use_detector, self.weights, self.run_types[self.run_date])
            self.m_staticText_run_total.SetLabel('{0:0.0f}'.format(self.run_total))
            self.m_staticText_run_true_positives.SetLabel('{0:0.0f}'.format(self.run_true_positives))
            self.m_staticText_run_false_positives.SetLabel('{0:0.0f}'.format(self.run_false_positives))
            self.m_staticText_run_false_negatives.SetLabel('{0:0.0f}'.format(self.run_false_negatives))

            self.run_accuracy_details = pd.DataFrame(run_object_details, columns=self.run_accuracy_details_columns)

            self.run_accuracy = run_stats[0]
            self.m_staticText_run_accuracy.SetLabel('Accy: {0:0.4f}'.format(self.run_accuracy))
            self.run_precision = run_stats[1]
            self.m_staticText_run_precision.SetLabel('Prec: {0:0.4f}'.format(self.run_precision))
            self.run_recall = run_stats[2]
            self.m_staticText_run_recall.SetLabel('Rcall: {0:0.4f}'.format(self.run_recall))

            self.isOld['accuracy'] = False
            self.isOld['accuracy_settings'] = False
            at2 = None

        # save the image to file
        if self.enable_save_png:
            save_image_to_png(self)

        # log the settings, lidar, detection and association data to csv files
        if self.enable_logging:
            log_to_file(self)

        # show the kitti points
        if self.show_kitti_points:
            self.m_checkBox_show_all_kitti_points.Enable()
        else:
            self.m_checkBox_show_all_kitti_points.Disable()

        # update the bitmap in the GUI panel
        self.bmp = wx.Bitmap.FromBuffer(self.image_cols, self.image_rows, self.display_image)
        self.m_panel_video_display.SetSize((self.image_cols, self.image_rows))
        dc = wx.BufferedPaintDC(self.m_panel_video_display)
        dc.DrawBitmap(self.bmp, 0, 0)

        # update the current frame info
        self.m_staticText_current_frame.SetLabelText('Current Frame: {}'.format(int(self.current_frame)))

        min_last = self.min_distance
        max_last = self.max_distance
        min_det_confidence_last = self.min_det_confidence
        try:
            self.min_distance = int(self.m_textCtrl_min_distance.GetValue())
            self.max_distance = int(self.m_textCtrl_max_distance.GetValue())
            self.min_det_confidence = float(self.m_textCtrl_min_det_confidence.GetValue())
            if min_last != self.min_distance or max_last != self.max_distance or min_det_confidence_last != self.min_det_confidence:
                self.isOld['filtered'] = True
        except:
            print('Unable to read value')

        for child in self.Children:
            child.Refresh()
        return

    def create_gt_record_df(self):
        self.record_gt_filepath = self.m_textCtrl_record_gt_filepath.GetValue()
        filepath = os.path.join(self.record_gt_filepath, 'gt_record_{}_{}.csv'.format(self.run_date, self.run_number))
        if not os.path.exists(self.record_gt_filepath):
            os.mkdir(self.record_gt_filepath)

        if not os.path.exists(filepath):
            # this is a new ground truth record
            self.gt_record_df = pd.DataFrame([], columns=self.gt_record_columns)
        else:
            # read the existing record from file
            self.gt_record_df = pd.read_csv(filepath)
        return

    def save_gt_record_df(self):
        self.record_gt_filepath = self.m_textCtrl_record_gt_filepath.GetValue()
        filepath = os.path.join(self.record_gt_filepath, 'gt_record_{}_{}.csv'.format(self.run_date, self.run_number))

        if not os.path.exists(self.record_gt_filepath):
            os.mkdir(self.record_gt_filepath)
        self.gt_record_df.to_csv(filepath, index=False)

        # cause the ground truth to be read back in
        self.isOld['ground_truth'] = True
        self.isOld['image'] = True
        self.Refresh()
        return

    def update_association_gt(self, x, y):
        npixels = 10
        self.update_association_frame_number = self.current_frame
        for i in range(len(self.association_frame['assignments'])):
            (det_idx, lidar_idx) = self.association_frame['assignments'][i]
            if abs(self.lidar_frame.iloc[lidar_idx,5] - x) <= npixels  and abs(self.lidar_frame.iloc[lidar_idx,6] - y) < npixels:
                if i not in self.remove_association_idx_frame:
                    self.remove_association_idx_frame.append(i)
                else:
                    self.remove_association_idx_frame.remove(i)
        return

    def manual_association_gt(self, x, y):
        npixels = 7
        if self.right_click_idx == 0:
            for i in range(len(self.association_frame['assignments'])):
                (det_idx, lidar_idx) = self.association_frame['assignments'][i]
                if abs(self.det_frame.iloc[det_idx,4] - x) <= npixels and abs(self.det_frame.iloc[det_idx,5] - y) < npixels:
                    if i not in self.remove_association_idx_frame: # this is the first time this blue circle was clicked - add it to the remove list
                        self.remove_association_idx_frame.append(i)
                        # save the object to the right_click
                        self.right_click_selected_object = det_idx
                        self.right_click_association_idx = i
                        self.right_click_idx = 1
                        self.show_right_click_message = True

                    else: # this is a blue circle that has already been removed (determine if it was added to the manual list)
                        for j in range(len(self.manual_associations_gt)):
                            # if it is in the manual associations list - remove it
                            if self.association_frame['assignments'][i][0] == self.manual_associations_gt[j][0]:
                                self.manual_associations_gt.remove(self.manual_associations_gt[j])
                                self.remove_association_idx_frame.remove(i)
                else: # this is a click outside the range of any of the blue circles
                    pass

        else: # right_click_idx = 1
            notdone = True
            # look for clicks on lidar distances
            for j in range(len(self.right_click_lidar_locations)):
                if abs(self.right_click_lidar_locations[j][0] + 9 - x) <= npixels and abs(self.right_click_lidar_locations[j][1] - 6 - y) <= npixels and notdone:
                    # found a click on a lidar distance number - add the det index and the lidar index to the manual_associations_gt list
                    manual_values = [self.right_click_selected_object, # det_index
                                     j, # lidar_index
                                     True, # is_manual
                                     -1, # distance
                                     False] # recorded
                    self.manual_associations_gt.append( manual_values )
                    self.manual_associations_idx_frame.append(self.right_click_selected_object)
                    self.right_click_selected_object = -1
                    self.right_click_idx = 0
                    notdone = False

            if abs(self.det_frame.iloc[self.right_click_selected_object, 4] - x) <= npixels and abs(self.det_frame.iloc[self.right_click_selected_object, 5] - y) < npixels and notdone:
                # user clicked on blue circle again to cancel the selection
                self.right_click_idx = 0
                self.remove_association_idx_frame.remove(self.right_click_selected_object) # put back in valid associations
                self.right_click_selected_object = -1
        a = 1
        return

    def add_manual_distance(self):
        if self.right_click_idx == 1:
            dlg = wx.TextEntryDialog(frame, 'Enter distance', 'Enter the distance for the object')
            dlg.SetValue("")
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    manual_distance = float(dlg.GetValue())
                    manual_values = [self.right_click_selected_object,  # det_index
                                     -1,  # no lidar_index
                                     True,  # is_manual
                                     manual_distance, # distance
                                     False]  # recorded
                    self.manual_associations_gt.append(manual_values)
                    self.manual_associations_idx_frame.append(self.right_click_selected_object)
                    self.right_click_idx = 0
                    if self.right_click_selected_object not in self.remove_association_idx_frame:
                        self.remove_association_idx_frame.append(self.right_click_selected_object)
                    self.right_click_selected_object = -1
                except:
                    print('invalid distance entered')
            dlg.Destroy()
        else:
            dlg = wx.TextEntryDialog(frame, 'Enter object index and distance', 'Enter the object index and distance (separate by comma)')
            dlg.SetValue("")
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    strlist =  dlg.GetValue().split(',')
                    manual_idx = int(strlist[0])
                    manual_distance = float(strlist[1])
                    manual_values = [manual_idx,  # det_index
                                     -1,  # no lidar_index
                                     True,  # is_manual
                                     manual_distance, # distance
                                     False]  # recorded
                    self.manual_associations_gt.append(manual_values)
                    self.manual_associations_idx_frame.append(self.right_click_selected_object)
                    self.right_click_idx = 0
                    if self.right_click_selected_object not in self.remove_association_idx_frame:
                        self.remove_association_idx_frame.append(self.right_click_selected_object)
                    self.right_click_selected_object = -1
                except:
                    print('invalid values entered: enter a index, distance pair separated by a comma')
            dlg.Destroy()

        return

    def record_gt(self):
        # this method is fired when the user presses the enter key with the record_gt checkbox checked
        # get data for current frame from full dataframe
        self.update_association_frame_number = self.current_frame
        self.gt_record_df = self.gt_record_df[self.gt_record_df.det_frame != self.current_frame]

        # go through association_frame and determine which associations have been labeled as not valid
        # if the association index number is not in the manual_associations_idx_frame list and
        # is in the list remove_association_idx_frame then the association index is not valid as a ground truth distance
        for i in range(len(self.association_frame['assignments'])):
            if self.association_frame['assignments'][i][0] not in self.manual_associations_idx_frame:
                if i not in self.remove_association_idx_frame:
                    is_valid = True
                else:
                    is_valid = False

                (det_idx, lidar_idx) = self.association_frame['assignments'][i]
                # add the association to the gt_record_df dataframe as a ground_truth
                newrow = [self.det_frame.iloc[det_idx, 0], # det_frame
                          self.lidar_frame.iloc[lidar_idx, 0], # lidar_frame
                          i, # association_index
                          is_valid,
                          False, # is_manual_distance
                          det_idx, # Video_detection_index
                          lidar_idx, # lidar_detection_index
                          self.det_frame.iloc[det_idx, 2],  # detection_class
                          self.det_frame.iloc[det_idx, 3], # detection_confidence
                          self.lidar_frame.iloc[lidar_idx, 2], # lidar_segment
                          self.lidar_frame.iloc[lidar_idx, 3], # lidar_distance
                          self.det_frame.iloc[det_idx, 4], # detection bbox x1
                          self.det_frame.iloc[det_idx, 5], # y1
                          self.det_frame.iloc[det_idx, 6], # x2
                          self.det_frame.iloc[det_idx, 7] # y2
                          ]
                self.gt_record_df = self.gt_record_df.append(pd.DataFrame([newrow], columns=self.gt_record_columns), ignore_index=True)

        self.remove_association_idx_frame = []
        self.manual_associations_idx_frame = []

        for i in range(len(self.manual_associations_gt)):
            [det_idx, lidar_idx, is_manual, manual_distance, is_recorded] = self.manual_associations_gt[i]
            if lidar_idx != -1:
                lidar_frame = self.lidar_frame.iloc[lidar_idx, 0]
                lidar_segment = self.lidar_frame.iloc[lidar_idx, 2]
                lidar_distance = self.lidar_frame.iloc[lidar_idx, 3]
            else:
                lidar_frame = -1
                lidar_segment = -1
                lidar_distance = manual_distance

            newrow = [self.det_frame.iloc[det_idx, 0], # det_frame
                      lidar_frame, # lidar_frame number
                      i, # association index
                      True, # is_valid
                      is_manual, # is this a manual assignment
                      det_idx,
                      lidar_idx,
                      self.det_frame.iloc[det_idx, 2], # detection class
                      self.det_frame.iloc[det_idx, 3], # detection confidence
                      lidar_segment, # lidar_segment
                      lidar_distance , # lidar_distance
                      self.det_frame.iloc[det_idx, 4], # object_bbox x1
                      self.det_frame.iloc[det_idx, 5], # y1
                      self.det_frame.iloc[det_idx, 6], # x2
                      self.det_frame.iloc[det_idx, 7]  # y2
                      ]
            self.gt_record_df = self.gt_record_df.append(pd.DataFrame([newrow], columns=self.gt_record_columns), ignore_index=True)
            self.manual_associations_gt = []

        self.gt_record_df.sort_values(['det_frame', 'association_index'], inplace=True)

        # update the ground truth dataframe
        self.at.update_gt_df(self.gt_record_df)

        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        return

    def calc_click_dist(self, x, y):
        if self.run_type == 'kitti':
            cal = cal_kitti
        elif self.run_type == 'santaclara':
            cal = cal_santaclara
        else:
            print('error: wrong run type given')

        h_camera = cal.cal['HT_CAMERA']
        xc = cal.cal['X_CENTER']
        yc = cal.cal['Y_HORIZON']
        xres = cal.cal['X_RESOLUTION']
        yres = cal.cal['Y_RESOLUTION']
        hfov = cal.cal['HFOV']
        vfov = cal.cal['VFOV']
        try:
            num = h_camera / math.tan((y-yc)/yres*vfov)
            denom = math.cos((x-xc)/xres*hfov)
            dist = math.sqrt((num/denom)**2 + h_camera**2)
        except:
            dist = -1
        return dist

    # from here to end of file these are the event handlers, overrided from the parent class
    def process_get_data( self, event ):
        '''button is pressed'''
        set_is_old(self.isOld, 'all_true')
        self.m_button_get_data.Disable()
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_choose_run_date( self, event ):
        '''dropdown is changed'''
        self.run_date_idx = event.Selection
        self.run_date = self.run_dates[self.run_date_idx]
        update_run_number(self)
        self.m_button_get_data.Enable()
        set_is_old(self.isOld, 'list_true',list=['dataset'])
        self.Refresh()
        self.TopLevelParent.Refresh()

        return

    def process_choose_run_number( self, event ):
        '''dropdown is changed'''
        self.run_number_idx = event.Selection
        update_run_number(self)
        self.m_button_get_data.Enable()
        set_is_old(self.isOld, 'list_true',list=['dataset'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_num_lidar_segs( self, event ):
        '''dropdown is changed'''
        self.n_segs_idx = event.Selection
        self.n_segs = self.n_segs_choices[self.n_segs_idx]
        self.seg_step = 16 // self.n_segs
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_show_coord( self, event ):
        '''checkbox is changed'''
        self.show_coord = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_use_detector(self, event):
        '''dropdown box is changed '''
        # TODO - add option to use the yolo detector live rather than preprocess
        self.use_detector = (event.String == 'True')
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_use_filtered_data( self, event ):
        '''ucheckbox is changed'''
        self.use_filtered_data = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_enable_min_det_confidence( self, event ):
        ''' checkbox is changed'''
        self.enable_min_det_confidence = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_show_index_numbers( self, event ):
        ''' checkbox is changed'''
        self.show_index_numbers = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_kitti_points( self, event ):
        ''' checkbox is changed'''
        self.show_kitti_points = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_all_kitti_points( self, event ):
        ''' checkbox is changed'''
        self.show_all_kitti_points = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_detection_zones(self, event):
        ''' checkbox is changed'''
        self.show_detection_zones = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_detection_zone_color(self, event):
        self.detection_zone_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_video_detections(self, event):
        ''' checkbox is changed'''
        self.show_video_detections = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_video_detections_color(self, event):
        self.video_detections_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_lidar_detections(self, event):
        ''' checkbox is changed'''
        self.show_lidar_detections = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_lidar_detections_color(self, event):
        self.lidar_detections_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_ground_truth(self, event):
        ''' checkbox is changed'''
        self.show_ground_truth = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_ground_truth_color(self, event):
        self.ground_truth_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_associations(self, event):
        ''' checkbox is changed'''
        self.show_associations = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_associations_color(self, event):
        self.associations_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_3d_ground_truth( self, event ):
        ''' checkbox is changed'''
        self.show_3d_ground_truth = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_3d_ground_truth_color( self, event ):
        self.threeD_ground_truth_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_show_lidar_values( self, event ):
        ''' checkbox is changed'''
        self.show_lidar_values = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_lidar_value_color( self, event ):
        self.lidar_value_color = event.Colour
        set_is_old(self.isOld, 'list_true', list=['image'])
        self.Refresh()
        return

    def process_enable_logging( self, event ):
        ''' checkbox is changed'''
        self.enable_logging = (event.Selection == 1)
        if self.enable_logging:
            self.last_frame_logged = -1 # used to test for new logging file
            self.logging_filepath = self.m_textCtrl_logging_filepath.GetValue()
        self.Refresh()
        return

    def process_enable_save_png( self, event ):
        ''' checkbox is changed'''
        self.enable_save_png = (event.Selection == 1)
        if self.enable_save_png:
            self.last_frame_png_saved = -1
            self.logging_filepath = self.m_textCtrl_logging_filepath.GetValue()
        self.Refresh()
        return

    def process_update_image( self, event ):
        '''button is pressed'''
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_step_backward(self, event):
        '''image is clicked'''
        self.current_frame -= 1
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_step_backward10(self, event):
        '''image is clicked'''
        self.current_frame -= 10
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_step_forward(self, event):
        '''image is clicked'''
        self.current_frame += 1
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_step_forward10(self, event):
        '''image is clicked'''
        self.current_frame += 10
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_play( self, event ):
        '''image is clicked'''
        if self.is_playing:
            self.is_playing = False
        else:
            self.is_playing = True
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_play_speed( self, event ):
        '''dropdown in changed'''
        self.play_speed_idx = event.Selection
        self.timer.Start(self.play_speeds[self.play_speed_idx])
        return

    def process_goto_frame_number(self, event):
        '''button is pressed'''
        try:
            value = int(self.m_textCtrl_goto_frame_number.GetValue())
            if value < self.run_start_frame & value <= self.run_stop_frame:
                self.current_frame = self.run_start_frame
            elif value > self.run_stop_frame:
                self.current_frame = self.run_stop_frame
            else:
                self.current_frame = value
            self.m_textCtrl_goto_frame_number.SetValue(str(self.current_frame))
            set_is_old(self.isOld, 'list_true',
                       list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters'])
            self.Refresh()
            self.TopLevelParent.Refresh()
        except:
            self.m_textCtrl_goto_frame_number.SetValue(str(self.current_frame))
        return

    def process_lag_frames( self, event ):
        '''dropdown in changed'''
        self.lag_frames_idx = event.Selection
        self.lag_frames = self.lag_frames_choices[self.lag_frames_idx]
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_enable_max_cost( self, event ):
        ''' checkbox is changed'''
        self.enable_max_cost = (event.Selection == 1)
        set_is_old(self.isOld, 'list_true',
                   list=['image', 'gt_frame', 'det_frame', 'lidar_frame', 'association', 'clusters', 'accuracy_settings'])
        self.Refresh()
        self.TopLevelParent.Refresh()
        return

    def process_use_intersecting_only( self, event ):
        ''' checkbox is changed'''
        self.use_intersecting_only = (event.Selection == 1)
        self.Refresh()
        return

    def process_update_results( self, event ):
        self.isOld['accuracy'] = True
        self.Refresh()
        return

    def process_display_data_viewer(self, event):
        '''button is pressed'''
        data_viewer = MyFrame_Data_Viewer(wx.GetApp().TopWindow, parent_data = self)
        data_viewer.Show()
        return

    def process_enable_record_gt( self, event ):
        ''' checkbox is changed'''
        if not self.enable_record_gt:
            self.create_gt_record_df()
        else:
            self.save_gt_record_df()

        self.enable_record_gt = (event.Selection == 1)
        self.Refresh()
        return

    def process_display_kitti_viewer( self, event ):
        '''button is pressed'''
        kitti_viewer = MyFrame_Kitti_Viewer(wx.GetApp().TopWindow, parent_data = self)
        kitti_viewer.Show()
        return

    def process_mouse_left_down( self, event ):
        '''left mouse button is pressed in the image area'''
        if self.show_coord:
            self.mouse_x = event.x
            self.mouse_y = event.y
            self.click_dist = self.calc_click_dist(event.x, event.y)
            set_is_old(self.isOld, 'list', list=['image'])
        if self.enable_record_gt:
            self.m_panel_video_display.SetFocusFromKbd()
            self.update_association_gt(event.x, event.y)
            set_is_old(self.isOld, 'list', list=['image'])
        self.Refresh()
        return

    def process_mouse_right_down( self, event ):
        '''right mouse button is pressed in the image area'''
        if self.enable_record_gt:
            self.m_panel_video_display.SetFocusFromKbd()
            self.manual_association_gt(event.x, event.y)
            set_is_old(self.isOld, 'list', list=['image'])
        self.Refresh()
        return


# this starts the application
app = wx.App()
frame = MyFrame()
frame.Show()
app.MainLoop()

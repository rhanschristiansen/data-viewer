import numpy as np
import wx
from src.gui_form.frame import Frame_Data_Viewer


class MyFrame_Data_Viewer(Frame_Data_Viewer):
    '''This class is derived from Frame_Data_Viewer which is created by a application called wxFormBuilder

    The definition of the Frame_Data_Viewer is in the file frame.py which is auto generated by wxFormBuilder
    This class displays data on the Viewer pop up window that opens when the Data Viewer button is pressed
    Multiple instances of this window may be opened
    '''
    def __init__(self, parent, parent_data=None):
        Frame_Data_Viewer.__init__(self, parent=wx.GetApp().TopWindow)
        self.Bind(wx.EVT_PAINT, self.onPaint)
        self.parent = parent
        self.parent_data = parent_data
        self.min_grid_rows = 100
        self.use_detector = self.parent_data.use_detector
        self.update_grids()
        self.at = self.parent_data.at
        self.current_frame = self.parent.current_frame
        self.gt_frame = self.at.gt_frame
        self.det_frame = self.at.det_frame
        self.lidar_frame = self.at.lidar_frame
        self.association_frame = self.at.association_frame
        self.assignments_frame = []
        self.total_cost_frame = np.zeros((1, 1), np.float)
        self.l2_norm_cost_frame = np.zeros((1, 1), np.float)
        self.y2_est_cost_frame = np.zeros((1, 1), np.float)
        self.iou_cost_frame = np.zeros((1, 1), np.float)
        self.seg_intersect_cost_frame = np.zeros((1, 1), np.float)

        return

    def update_grids(self):
        # this is the main method that is called by the onPaint to keep the data up to date with the frame

        # get the data from the parent window
        self.at = self.parent_data.at
        self.current_frame = self.parent.current_frame
        self.gt_frame = self.at.gt_frame
        self.det_frame = self.at.det_frame
        self.lidar_frame = self.at.lidar_frame
        self.association_frame = self.at.association_frame

        if len(self.association_frame['assignments']) > 0:
            self.assignments_frame = self.association_frame['assignments']
        else:
            self.assignments_frame = []

        if len(self.det_frame) > 0 and len(self.lidar_frame) > 0:
            self.total_cost_frame = self.association_frame['total_costs']
            self.l2_norm_cost_frame = self.association_frame['cost_components'][0]
            self.y2_est_cost_frame = self.association_frame['cost_components'][1]
            self.iou_cost_frame = self.association_frame['cost_components'][2]
            self.seg_intersect_cost_frame = self.association_frame['cost_components'][3]
        else:
            self.total_cost_frame = np.zeros((1,1),np.float)
            self.l2_norm_cost_frame = np.zeros((1,1),np.float)
            self.y2_est_cost_frame = np.zeros((1,1),np.float)
            self.iou_cost_frame = np.zeros((1,1),np.float)
            self.seg_intersect_cost_frame = np.zeros((1,1),np.float)

        # update the Ground Truth, Detections and Lidar grids
        # these are processed as lists in the for loop below
        dfs = [self.gt_frame, self.det_frame, self.lidar_frame]
        grids = [self.m_grid_ground_truth_data, self.m_grid_detection_data, self.m_grid_lidar_data]
        colors = [self.parent_data.m_colourPicker_ground_truth.Colour,
                  self.parent_data.m_colourPicker_video_detections.Colour,
                  self.parent_data.m_colourPicker_lidar_detections.Colour]

        for df, grid, color, in zip(dfs, grids, colors):
            grid.ClearGrid()
            # resize the grids for the new number of readings
            (r, c) = df.shape
            r_df = r
            r = max(r, self.min_grid_rows)
            r_old = grid.GetNumberRows()
            c_old = grid.GetNumberCols()
            if r_old < r:
                grid.AppendRows(r - r_old)
            else:
                grid.DeleteRows(numRows=r_old - r)
            if c_old < c:
                grid.AppendCols(c - c_old)
            else:
                grid.DeleteCols(numCols=c_old - c)
            cols = list(df.columns.values)

            # update the column labels
            for i, col in enumerate(cols):
                grid.SetColLabelValue(i, col)

            # update the values and add the color index to the frame column
            for i in range(r_df):
                for j in range(c):
                    val = str(df.iloc[i, j])
                    grid.SetCellValue(i, j, val)
                    if j == 0:
                        grid.SetCellBackgroundColour(i, j, color)

            # clear the back ground color below the area of the data
            for i in range(r_df, self.min_grid_rows):
                grid.SetCellBackgroundColour(i, 0, (255, 255, 255, 255))


        # fill in the Associations Grid
        # the associations grid is much more complex and requires 2 columns for each association
        grid = self.m_grid_associations
        grid.ClearGrid()

        # resize the grid to the new number of associations
        r_old = grid.GetNumberRows()
        c_old = grid.GetNumberCols()
        row_labels = ['','','frame','index','class','confidence','segment','cluster','distance','cost','x1','y1','x2','y2']
        r = len(row_labels)
        c = 2*len(self.assignments_frame)
        if r_old < r:
            grid.AppendRows(r - r_old)
        else:
            grid.DeleteRows(numRows=r_old - r)
        if c_old < c:
            grid.AppendCols(c - c_old)
        elif c_old > 0:
            grid.DeleteCols(numCols=c_old - c)

        # update the row labels in the associations grid
        for i in range(len(row_labels)):
            grid.SetRowLabelValue(i,row_labels[i])

        # update the first two rows which have labels for the columns in the associations grid
        row1 = []
        row2 = []
        for i in range(len(self.assignments_frame)):
            row1.append('Association')
            row1.append('Index: ' + str(i))
            if self.use_detector:
                row2.append('Det')
            else:
                row2.append('GT')
            row2.append('Lidar')

        for j in range(len(row1)):
            grid.SetCellValue(0,j,row1[j])
            grid.SetCellValue(1,j,row2[j])

        # get the data frames based on the use_detector value
        # frame1 contains either the Ground Truth data or the Detection Data
        # frame2 always contains the LIDAR data
        if self.use_detector:
            frame1 = self.det_frame
        else:
            frame1 = self.gt_frame
        frame2 = self.lidar_frame

        # populate the data in the associations grid
        for j in range(len(self.assignments_frame)):
            index1 = self.assignments_frame[j][0]
            index2 = self.assignments_frame[j][1]
            grid.SetCellValue(2,2*j,str(frame2.iloc[index2,0])) #frame 1&2
            grid.SetCellValue(2,2*j+1,str(frame2.iloc[index2,0]))
            grid.SetCellValue(3,2*j,str(frame1.iloc[index1,1])) #index 1&2
            grid.SetCellValue(3,2*j+1,str(frame2.iloc[index2,1]))
            grid.SetCellValue(4,2*j,str(frame1.iloc[index1,2])) #class 1
            if self.use_detector:
                grid.SetCellValue(5,2*j,'{0:0.4f}'.format(frame1.iloc[index1,3])) #confidence det only
            grid.SetCellValue(6,2*j+1,str(frame2.iloc[index2,2]))  #segment lidar only
            grid.SetCellValue(7,2*j+1,'{0:0.0f}'.format(frame2.iloc[index2,4]))  #cluster lidar only

            if not self.use_detector:
                grid.SetCellValue(8,2*j,'{0:0.4f}'.format(frame1.iloc[index1,3])) #dist gt and lidar only
            grid.SetCellValue(8,2*j+1,'{0:0.4f}'.format(frame2.iloc[index2,3]))

            # total_cost 1
            total_cost = self.total_cost_frame[index1,index2]
            grid.SetCellValue((9,2*j),'{0:0.4f}'.format(total_cost))
            if self.parent_data.enable_max_cost and (total_cost > self.parent_data.max_cost):
                grid.SetCellTextColour(9, 2*j, (255,0,0,255))

            grid.SetCellValue(10,2*j,str(frame1.iloc[index1,4])) #x1 1&2
            grid.SetCellValue(10,2*j+1,str(frame2.iloc[index2,5]))

            grid.SetCellValue(11,2*j,str(frame1.iloc[index1,5])) #y1 1&2
            grid.SetCellValue(11,2*j+1,str(frame2.iloc[index2,6]))

            grid.SetCellValue(12,2*j,str(frame1.iloc[index1,6])) #x2 1&2
            grid.SetCellValue(12,2*j+1,str(frame2.iloc[index2,7]))

            grid.SetCellValue(13,2*j,str(frame1.iloc[index1,7])) #y2 1&2
            grid.SetCellValue(13,2*j+1,str(frame2.iloc[index2,8]))

        # fill in the cost data in the total_cost, l2_norm_cost, y2_est_cost and iou_cost grids
        dfs = [self.total_cost_frame, self.l2_norm_cost_frame, self.y2_est_cost_frame, self.iou_cost_frame, self.seg_intersect_cost_frame]
        grids = [self.m_grid_total_cost, self.m_grid_l2_norm_cost, self.m_grid_y2_est_cost, self.m_grid_iou_cost, self.m_grid_seg_intersect]
        for df, grid in zip(dfs, grids):
            grid.ClearGrid()

            # reshape the grid to the new size
            [c, r] = np.shape(df)
            r_df = r
            r = max(r, self.min_grid_rows)
            r_old = grid.GetNumberRows()
            c_old = grid.GetNumberCols()
            if r_old < r:
                grid.AppendRows(r - r_old)
            else:
                grid.DeleteRows(numRows=r_old - r)
            if c_old < c:
                grid.AppendCols(c - c_old)
            else:
                grid.DeleteCols(numCols=c_old - c)

            # clear the old background colors
            for i in range(grid.GetNumberRows()):
                for j in range(grid.GetNumberCols()):
                    grid.SetCellBackgroundColour(i, j, (255, 255, 255, 255))
                    grid.SetCellTextColour(i, j, (0, 0, 0, 255))

            # fill in the new data
            for i in range(r_df):
                grid.SetRowLabelValue(i, str(i))
            for j in range(c):
                grid.SetColLabelValue(j, str(j))
                for i in range(r_df):
                    grid.SetCellValue(i, j, '{0:0.4f}'.format(df[j, i]))

        # paint the background color of the assignments in the cost grids so that
        # the user can easily identify which costs won in the munkres assignment
        color = self.parent_data.m_colourPicker_associations.Colour
        for asmt in self.assignments_frame:
            total_cost = self.total_cost_frame[asmt[0],asmt[1]]
            if self.parent_data.enable_max_cost and (total_cost > self.parent_data.max_cost):
                self.m_grid_total_cost.SetCellTextColour(asmt[1],asmt[0],(255,0,0,255))
                self.m_grid_l2_norm_cost.SetCellTextColour(asmt[1],asmt[0],(255,0,0,255))
                self.m_grid_y2_est_cost.SetCellTextColour(asmt[1],asmt[0],(255,0,0,255))
                self.m_grid_iou_cost.SetCellTextColour(asmt[1],asmt[0],(255,0,0,255))
                self.m_grid_seg_intersect.SetCellTextColour(asmt[1],asmt[0],(255,0,0,255))
            else:
                self.m_grid_total_cost.SetCellBackgroundColour(asmt[1], asmt[0], color)
                self.m_grid_l2_norm_cost.SetCellBackgroundColour(asmt[1], asmt[0], color)
                self.m_grid_y2_est_cost.SetCellBackgroundColour(asmt[1], asmt[0], color)
                self.m_grid_iou_cost.SetCellBackgroundColour(asmt[1], asmt[0], color)
                self.m_grid_seg_intersect.SetCellBackgroundColour(asmt[1], asmt[0], color)

        return

    def onPaint(self, evt):
        # this method fires when the window changes or when the parent Viewer app calls:
        #        for child in self.Children:
        #            child.Refresh()
        #
        # at the end of its onPaint method

        self.update_grids()
        self.use_detector = self.parent_data.use_detector